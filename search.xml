<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何用js判断用户浏览器的版本]]></title>
      <url>%2F2017%2F04%2F28%2Fjs%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[问题描述：因为不同浏览器支持问题，需要根据不同浏览器版本展示不同的内容，所有需要用js判断用户浏览器的版本。 解决方案： 找到个封装的比较全的贴上来以备后用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174var BroswerUtil = &#123; //检测浏览器版本 getBrowserVersion: function() &#123; var agent = navigator.userAgent.toLowerCase(); var arr = []; var Browser = &quot;&quot;; var Bversion = &quot;&quot;; var verinNum = &quot;&quot;; //IE if(agent.indexOf(&quot;msie&quot;) &gt; 0) &#123; var regStr_ie = /msie [\d.]+;/gi; Browser = &quot;IE&quot;; Bversion = &quot;&quot; + agent.match(regStr_ie) &#125; //firefox else if(agent.indexOf(&quot;firefox&quot;) &gt; 0) &#123; var regStr_ff = /firefox\/[\d.]+/gi; Browser = &quot;firefox&quot;; Bversion = &quot;&quot; + agent.match(regStr_ff); &#125; //Chrome else if(agent.indexOf(&quot;chrome&quot;) &gt; 0) &#123; var regStr_chrome = /chrome\/[\d.]+/gi; Browser = &quot;chrome&quot;; Bversion = &quot;&quot; + agent.match(regStr_chrome); &#125; //Safari else if(agent.indexOf(&quot;safari&quot;) &gt; 0 &amp;&amp; agent.indexOf(&quot;chrome&quot;) &lt; 0) &#123; var regStr_saf = /version\/[\d.]+/gi; Browser = &quot;safari&quot;; Bversion = &quot;&quot; + agent.match(regStr_saf); &#125; //Opera else if(agent.indexOf(&quot;opera&quot;) &gt;= 0) &#123; var regStr_opera = /version\/[\d.]+/gi; Browser = &quot;opera&quot;; Bversion = &quot;&quot; + agent.match(regStr_opera); &#125; else &#123; var browser = navigator.appName; if(browser == &quot;Netscape&quot;) &#123; var version = agent.split(&quot;;&quot;); var trim_Version = version[7].replace(/[ ]/g, &quot;&quot;); var rvStr = trim_Version.match(/ [\d\.] / g).toString(); var rv = rvStr.replace(/[,]/g, &quot;&quot;); Bversion = rv; Browser = &quot;IE&quot; &#125; &#125; verinNum = (Bversion + &quot;&quot;).replace(/[^0-9.]/ig, &quot;&quot;); arr.push(Browser); arr.push(verinNum); return arr; &#125;, //检测是否是XX浏览器 WB: (function() &#123; var UserAgent = navigator.userAgent.toLowerCase(); return &#123; isIE6: /msie 6.0/.test(UserAgent), // IE6 isIE7: /msie 7.0/.test(UserAgent), // IE7 isIE8: /msie 8.0/.test(UserAgent), // IE8 isIE9: /msie 9.0/.test(UserAgent), // IE9 isIE10: /msie 10.0/.test(UserAgent), // IE10 isIE11: /msie 11.0/.test(UserAgent), // IE11 isLB: /lbbrowser/.test(UserAgent), // 猎豹浏览器 isUc: /ucweb/.test(UserAgent), // UC浏览器 is360: /360se/.test(UserAgent), // 360浏览器 isBaidu: /bidubrowser/.test(UserAgent), // 百度浏览器 isSougou: /metasr/.test(UserAgent), // 搜狗浏览器 isChrome: /chrome/.test(UserAgent.substr(-33, 6)), // Chrome浏览器 isFirefox: /firefox/.test(UserAgent), // 火狐浏览器 isOpera: /opera/.test(UserAgent), // Opera浏览器 isSafire: /safari/.test(UserAgent) &amp;&amp; !/chrome/.test(UserAgent), // safire浏览器 isQQ: /qqbrowser/.test(UserAgent) //qq浏览器 &#125;; &#125;)(), //检测当前操作系统 CurrentSystem: (function() &#123; var system = &#123; win: false, mac: false, xll: false, iphone: false, ipoad: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, wii: false, ps: false &#125;; var ua = navigator.userAgent; // 检测平台 var p = navigator.platform; system.win = p.indexOf(&apos;Win&apos;) == 0; system.mac = p.indexOf(&apos;Mac&apos;) == 0; system.xll = (p.indexOf(&apos;Xll&apos;) == 0 || p.indexOf(&apos;Linux&apos;) == 0); // 检测Windows操作系统 if(system.win) &#123; if(/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua)) &#123; if(RegExp[&apos;$1&apos;] == &apos;NT&apos;) &#123; switch(RegExp[&apos;$2&apos;]) &#123; case &apos;5.0&apos;: system.win = &apos;2000&apos;; break; case &apos;5.1&apos;: system.win = &apos;XP&apos;; break; case &apos;6.0&apos;: system.win = &apos;Vista&apos;; break; case &apos;6.1&apos;: system.win = &apos;7&apos;; break; case &apos;6.2&apos;: system.win = &apos;8&apos;; break; default: system.win = &apos;NT&apos;; break; &#125; &#125; else if(RegExp[&apos;$1&apos;] == &apos;9x&apos;) &#123; system.win = &apos;ME&apos;; &#125; else &#123; system.win = RegExp[&apos;$1&apos;]; &#125; &#125; &#125; // 移动设备 system.iphone = ua.indexOf(&apos;iPhone&apos;) &gt; -1; system.ipod = ua.indexOf(&apos;iPod&apos;) &gt; -1; system.ipad = ua.indexOf(&apos;iPad&apos;) &gt; -1; system.nokiaN = ua.indexOf(&apos;nokiaN&apos;) &gt; -1; // windows mobile if(system.win == &apos;CE&apos;) &#123; system.winMobile = system.win; &#125; else if(system.win == &apos;Ph&apos;) &#123; if(/Windows Phone OS (\d+.\d)/i.test(ua)) &#123; system.win = &apos;Phone&apos;; system.winMobile = parseFloat(RegExp[&apos;$1&apos;]); &#125; &#125; // 检测IOS版本 if(system.mac &amp;&amp; ua.indexOf(&apos;Mobile&apos;) &gt; -1) &#123; if(/CPU (?:iPhone )?OS (\d+_\d+)/i.test(ua)) &#123; system.ios = parseFloat(RegExp[&apos;$1&apos;].replace(&apos;_&apos;, &apos;.&apos;)); &#125; else &#123; system.ios = 2; // 不能真正检测出来，所以 只能猜测 &#125; &#125; // 检测Android版本 if(/Android (\d+\.\d+)/i.test(ua)) &#123; system.android = parseFloat(RegExp[&apos;$1&apos;]); &#125; // 游戏系统 system.wii = ua.indexOf(&apos;Wii&apos;) &gt; -1; system.ps = /PlayStation/i.test(ua); return &#123; system: system &#125; &#125;)()&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何用js禁用某个div的鼠标事件]]></title>
      <url>%2F2017%2F04%2F28%2Fjs%E7%A6%81%E7%94%A8%E9%BC%A0%E6%A0%87%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[问题描述：我希望禁用指定div上的所有鼠标事件，包括左键，中键，右键。 解决方案：1234567// 给指定div注册鼠标按下事件div.addEventListener(&apos;mousedown&apos;,mouseEvent,true);// 给指定div注册上下文菜单事件div.addEventListener(&apos;contextmenu&apos;,mouseEvent,true);function mouseEvent(e)&#123; e.preventDefault(); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态加载js时的依赖关系]]></title>
      <url>%2F2017%2F04%2F28%2F%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDjs%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%2F</url>
      <content type="text"><![CDATA[问题描述：我需要通过js动态加载两个js文件，但是他们有依赖关系，需要先加载一个，加载完成后再加载另一个。 解决方案： 动态加载脚本 1234var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; script.src=&quot;1.js&quot;; document.body.appendChild(script); // 在这之前不会下载脚本,添加到dom中才开始下载 这种方式在元素被添加到页面之后立刻开始下载，这样无论在何处启动下载，文件的下载和运行都不会阻塞其它的页面处理过程，甚至可以将代码放在head部分而不会对其余部分的脚本产生影响，下载文件的HTTP链接的情况除外。那么怎么知道脚本下载完成了呢，我们可以跟踪具体的事件 增加加载完成后的事件监听 1234567891011121314151617181920212223// 页面使用动态脚本加载时候，返回的代码会立即执行，但是FF和Opera会等待此前所有的动态脚本节点执行完毕var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; //我们需要检测脚本的加载情况//FF,Opera,Chrome,Safari3+会在script节点接受完成之后发出load事件 script.onload=function() &#123; &#125; //IE不支持load，用readystatechange事件 script.onreadystatechange=function() &#123; if(script.readyState==&apos;loaded&apos;||script.onreadyState==&apos;complele&apos;) &#123; /*防止触发了loaded有触发complete，或者触发了complte又触发loaded*/ script.onreadystatechange=null; /*其它代码*/ &#125; &#125; /*注意：对于图片来说要先指定事件处理程序，因为指定src就会开始下载，但是script来说要添加到DOM中才会开始下载，因此顺序不那么重要了*/ script.src=&quot;1.js&quot;; document.body.appendChild(script); 封装成方法以便复用 123456789101112131415161718192021222324function loadScript(url,callback) &#123; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; //IE if(script.readyState) &#123; script.onreadystatechange=function() &#123; if(script.readyState==&apos;loaded&apos;||script.onreadyState==&apos;complele&apos;) &#123; script.onreadystatechange=null; callback &amp;&amp; callback(); &#125; &#125; &#125; //非IE else &#123; script.onload=function() &#123; callback &amp;&amp; callback(); &#125; &#125; script.src=url; document.body.appendChild(script); &#125; 这种方式不保证文件加载的顺序，在所有的浏览器中只有FF和Opera保证脚本按照指定的顺序执行，其它浏览器将按照服务器返回次序下载并执行不同的代码文件。于是可以按照下面的方式来加载文件： 12345loadScript(&quot;1.js&quot;,function() &#123; loadScript(&quot;2.js&quot;,function()&#123; loadScript(&quot;3.js&quot;); &#125;); &#125;); 这样可以保证加载顺序，但是文件多是效率不高，所以尽量使用requireJS或es6的 模块化开发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么要用settimeout而不用setinterval]]></title>
      <url>%2F2017%2F04%2F28%2F%E4%B8%BA%E4%BB%80%E4%B9%88%20%E8%A6%81%E7%94%A8settimeout%E8%80%8C%E4%B8%8D%E7%94%A8setinterval%20-%20Copy%2F</url>
      <content type="text"><![CDATA[问题描述：使用setInterval做循环时，如果执行的代码在间隔时间内没有执行完，最后会挤在一起执行。 解决方案： 原因：setInterval不会考虑代码的执行时间，有可能代码还没有执行完就再次调用了代码，这样所有没执行完的代码都会排在事件队列末尾，cpu空闲时一起执行了剩余的代码。（只是个人理解不一定准确） 我想要的效果是间隔固定时间后执行一段代码，代码执行完后，间隔相同的时间再次执行这段代码。 可以用settimeout实现 1234setTimeout(function()&#123; //do something setTimeout(arguments.callee, time); &#125;, time);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F28%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
